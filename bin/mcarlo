#!/usr/bin/env ruby

require 'ostruct'
require 'erb'
require 'wdstats'
require 'scriptingutils'
require 'tempfile'

class Array
  # return the type of the array in mcarlo terms:
  # a simple assignment, a formula, an array of values, an empty array
  def formtype
    j = join
    if j =~ /^[-+.[:digit:]]+$/ # numeric chars only?
      return :simple_assignment if size == 1
      return :array
    elsif j =~ /^dist\(/
      if j =~ /^dist\((['"])(normal|lognormal|uniform|triangular)\1,[-+.\d]+%?,[-+.\d]+%?(,[-+.\d]+%?)?\)/
        return :dist
      else
        quit("Distribution expression (#{j}) malformed")
      end
    elsif j =~ /^([^A-Za-z0-9(])/ 
      quit("A formula (#{join(' ')}) may not start with #{$1}")
    else
      return :formula
    end
  end
end

# make entry in @vars and return the name of the variable defined
def enter(k,v,str)
  line = "@vars.#{k} = #{v}"
  str << line.gsub(/@vars\./,'')+"\n"
  puts line.gsub(/@vars\./,'') if VERBOSE
  eval line
  k
end

Version = "2.08"
verbose,number,width,infile,list,seed = false,10000,8
OptionParser.new do |opt|
  opt.banner =  "#{MYNAME} - evaluatie van bedrijfsresultaten met MonteCarlo faciliteiten\n"
  opt.banner << "Usage: #{MYNAME} [options] filename"
  opt.separator "Options:"

  opt.on('-n','--number=INT',Integer,
      	'set number of runs to INT',
      	'must be a multiple of 100',
      	'default: 10,000') do |v|
    (v > 0) && (v % 100 == 0) or quit("The number of runs must be a multiple of 100")
    number = v
  end

  opt.on('-s','--seed=INT',Integer,'random seed - causes a fixed set of random numbers to be used') do |v| seed = v end

  opt.on('-w','--width=INT',Integer,'printing width for numbers, default: 8') do |v| width = v end

  opt.on('-l','--list=STRING',String,
    'variables to be displayed, comma-separated',
    'implies --verbose') do |v|
    list = v.split(',')
    verbose = true
  end

  opt.on('-h','--help',
    'print this help and exit'
  ) do puts opt.help; exit; end

  opt.on('-v','--verbose',
    'show values of all (or all --list-specified) variables for each step'
  ) do verbose = true end

  opt.on('-V','--version',
    'print version and exit'
  ) do print_version(RELEASE) end
  opt.parse!
end or quit("Error parsing options")

infile = ARGV[0] or quit("I need a filename")
test(?e,infile)  or quit("File #{infile} does not exist")
test(?r,infile)  or quit("File #{infile} is not readable")

which('gnuplot') or quit("Could not find executable gnuplot")
which('feedgnuplot') or quit("Could not find executable feedgnuplot")
@vars = OpenStruct.new
OPS = ['+','-','*','/','?',':','<','>','<=','>=','**']

VERBOSE = verbose
lineno = 0
routine = "def mccalc\n"
varlist,nonconst,varexp = [],[],Regexp.new(/([A-Z][a-zA-Z]*)/)

preamble = PREAMBLE.result(binding)

open(infile) do |infile|
  infile.readlines.each do |l|
    lineno += 1
    l.sub!(/#.*/,'')
    next if l =~ /^#/    # skip comment
    next if l =~ /^\s*$/ # skip lege regels
    # replace number-fields ending in % with number/100
    l.gsub!(/([-+.0-9]+)%/) { |x| x.to_f/100 }
    var,*form = l.chomp.split(/\s+/)
    form.map! do |x|
      # test validity of operators
      x.scan(/[-+*\/<>?:]+/).each do |op|
        OPS.index(op) or quit("Line #{lineno}: Operator #{op} is not allowed; maybe you need parentheses?")
      end
      x = nil if x.gsub(/\s+/,'').empty?
      x
    end

    case form.formtype
    when :simple_assignment
      varlist.push(enter(var,form[0],preamble))
    when :dist
        varlist.push(enter(var,form.join,preamble))
    when :formula
      form = form.join(' ')
      # in formula's, prefix names that are defined in @vars with `@vars.':
      form.gsub!(varexp) do
        if @vars.respond_to?($1)
          "@vars."+$1
        else
          quit("Line #{lineno}: Undefined variable #{$1}")
        end
      end
      varlist.push(enter(var,form,routine))
      nonconst.push(var) # remember which vars to prefix with _
    else # manual array
      varlist.push(enter(var,form.map { |x| x.to_f }.to_s+'.to_magic',preamble))
    end
  end
end

list ||= varlist
(l = list-varlist).empty? or quit("unknown variable#{l.size>1 ? 's' : ''} #{l} in --list option")
maxlen = varlist.map {|v| v.size}.max # max length of variable name

if VERBOSE
  puts 'stepping, type q to stop '
  list.each do |v|
    routine << "  puts '#{v.ljust(maxlen)}:'.sub(/^_/,'') + #{v}.pr(#{width})\n"
  end
  routine << %q{
    q = gets
    exit if q.strip == 'q'
  }
end
routine << "  return(_#{varlist[-1]})\nend\n\n"

# make internal vars non-constants with _ prefix
nonconst.each { |v|
  routine = routine.gsub(/\b#{v}\b/m,'_'+v).sub(/(^  puts .)_/m,'\1')
}

postamble = POSTAMBLE.result(binding)

script = preamble + routine + postamble
tf = Tempfile.new('mcarlo')
tf.puts script
tf.close
exec 'ruby '+tf.path

# __TEMPLATES__
BEGIN {
  require 'erb'

  PREAMBLE = ERB.new(<<-'EOD'.tr("\t",""),nil,'%')
	#!/usr/bin/env ruby
	# encoding: utf-8
	require 'wdstats'
	require 'rubystats'
	   number = <%= number %>
	    every = number/100
	     seed = <%= seed %>
	starttime = Time.now
	srand(seed.to_i) if seed
	EOD

  POSTAMBLE = ERB.new(<<-'EOD'.tr("\t",""),nil,'%')
	npv,mlast = [],[]
	plot = open(%Q{|feedgnuplot \
	  --lines --points \
	  --extracmds 'set logscale y2' \
	  --stream 0 \
	  --xmin 0 --xmax 100 \
	  --title "mcarlo2 n=<%= number %> seed=<%= seed || 'random'  %>" \
	  --y2 1 \
	  --stream \
	  --legend 0 '<%= varlist.last %> mean' \
	  --legend 1 'SD last 10' \
	  --ylabel '<%= varlist.last %> mean' \
	  --y2label 'SD last 10' 2>/dev/null},'w')
	% if VERBOSE
	puts "%11s %14s" % ["<%= varlist.last %>",'St. dev.']
	% end
	1.upto(number) do |i|
	  npv.push(mccalc)
	  s = 0
	  if i % every == 0
            if npv.size > 1 &&npv.uniq.size == 1
              puts("<%= varlist.last %> has a constant value of #{npv.shift}")
              exit 1
            end
	    m = npv.mean
	    mlast.push(m)
	    if mlast.size >=10
	      s = mlast[-10..-1].psd
	      plot.puts "#{m} #{s}"
	      plot.flush
	    end
	% if VERBOSE
	    puts [m.pr(<%= width %>),s.pr(<%= width %>)].join(' ')
	% end
	  end
	end
	puts npv.info("\nTest run with seed=<%= seed || 'random' %>")
	t = Time.now - starttime
	if t > 600 
	  t/=60
	  unit = 'minutes'
	else
	  unit = 'seconds'
	end
	puts "           Run time (%s): %#12.3g" % [unit,t]
        plot.close
	EOD
}
# $Id$
