#!/usr/bin/env ruby

require 'ostruct'
require 'erb'
require 'wdstats'
require 'tempfile'
require 'scriptingutils'
require_relative '../lib/mcarlo/version'
Version = Mcarlo::VERSION

class String 
  def beautify; self.gsub(/([a-z])([A-Z])/,'\1 \2').gsub(/([A-Z]+)([A-Z][a-z])/,'\1 \2'); end
end

class Array
  # return the type of the array in mcarlo terms:
  # a simple assignment, a formula, an array of values, an empty array
  def formtype
    j = join
    if j =~ /^[-+.[:digit:]]+$/ # numeric chars only?
      return :simple_assignment if size == 1
      return :array
    elsif j =~ /^dist\(/
      if j =~ /^dist\((['"])(normal|lognormal|uniform|triangular)\1,[-+.\d]+%?,[-+.\d]+%?(,[-+.\d]+%?)?\)/
        return :dist
      else
        quit("Distribution expression (#{j}) malformed")
      end
    elsif j =~ /^([^A-Za-z0-9(])/ 
      quit("A formula (#{join(' ')}) may not start with #{$1}")
    else
      return :formula
    end
  end
end

# make entry in @vars and return the name of the variable defined
def enter(k,v,str)
  @last = k
  line = "@vars.#{k} = #{v}"
  str << line.gsub(/@vars\./,'')+"\n"
  puts line.gsub(/@vars\./,'') if VERBOSE
  eval line
  k
end

def handle_options
  o = OpenStruct.new( 
    :distros   => nil,
    :list      => nil,
    :infile    => nil,
    :seed      => nil,
    :width     => 8,
    :number    => 10_000,
    :verbose   => nil,
    :ylog      => nil,
    :font      => 'Courier,10',
  )
  ARGV.options do |opt|
    opt.banner =  "#{MYNAME} - evaluatie van bedrijfsresultaten met MonteCarlo faciliteiten\n"
    opt.banner << "Usage: #{MYNAME} [options] filename"
    opt.separator "Options:"
 
    opt.on('-n','--number=INT',Integer,
        	'set number of runs to INT',
        	'must be a multiple of 100',
        	'default: 10,000') do |v|
      (v > 0) && (v % 100 == 0) or quit("The number of runs must be a multiple of 100")
      o.number = v
    end
 
    opt.on('-s','--seed=INT',Integer,
                'random seed - causes a fixed set of random numbers to be used') do |v| o.seed = v end
 
    opt.on('-w','--width=INT',Integer,'printing width for numbers, default: 8') do |v| o.width = v end
 
    opt.on('-l','--list=string',String,
      'variables to be displayed, comma-separated',
      'implies --verbose') do |v|
      o.list = v.split(',')
      o.verbose = true
    end
 
    opt.on('-p','--plot=string',String,
      'variables to be plotted, comma-separated') do |v|
      o.plot = v.split(',')
    end
 
    opt.on('-f','--font=string',String,
      'font for png output, default: "Courier,10"') do |v|
      o.font = v
    end

    opt.on('-y','--ylog','Frequency (left) Y-axis logarithmic for scatter plots') do o.ylog = true end
 
    opt.on('-h','--help',
      'print this help and exit'
    ) do puts opt.help; exit; end
 
    opt.on('-v','--verbose',
      'show values of all (or all --list-specified) variables for each step'
    ) do o.verbose = true end
 
    opt.on('-V','--version',
      'print version and exit'
    ) do print_version end
    opt.parse!
  end or quit("Error parsing options",1)
  o.infile = ARGV.shift
  if ! o.infile then
    if File.exist?('data.txt') then
      o.infile = 'data.txt' 
    else
      quit("I need a filename or your input file must be named data.txt")
    end
  end
  test(?e,o.infile)  or quit("File #{o.infile} does not exist")
  test(?r,o.infile)  or quit("File #{o.infile} is not readable")
  ARGV.empty? or quit("too many arguments: "+ARGV.join(" "))
  o
end


o = init(%w{gnuplot feedgnuplot},:handle_options)

@vars = OpenStruct.new
OPS = ['+','-','*','/','?',':','<','>','<=','>=','**']

@last = nil	# last variable - something like NPV
@singulars = []	# names of non-constant singular variables that were defined

lineno = 0
routine = "def mccalc\n"
varlist,varexp = [],Regexp.new(/([A-Z][a-zA-Z]*)/)

preamble = PREAMBLE.result(binding)

open(o.infile) do |infile|
  infile.readlines.each do |l|
    lineno += 1
    l.sub!(/\s*#.*/,'')
    next if l =~ /^\s*$/ # skip lege regels
    
    # replace number-fields ending in % with number/100
    l.gsub!(/([-+.0-9]+)%/) { |x| x.to_f/100 }
    var,*form = l.chomp.split(/\s+/)

    # catch options:
    if var =~ /--(.*)/ then
      op = $1
      if op =~/^(plot|list)/ then
        eval "o.#{op} = (form[0]||'').split(',')"
      else 
        eval "o.#{op} = form.join(' ')"
      end
      next
    end
    VERBOSE = o.verbose unless defined? VERBOSE
    form.map! do |x|
      # test validity of operators
      x.scan(/[-+*\/<>?:]+/).each do |op|
        OPS.index(op) or quit("Line #{lineno}: Operator #{op} is not allowed; maybe you need parentheses?")
      end
      x = nil if x.gsub(/\s+/,'').empty?
      x
    end

    case form.formtype
    when :simple_assignment
      varlist.push(enter(var,form[0],preamble))
    when :dist
        varlist.push(enter(var,form.join,preamble))
    when :formula
      form = form.join(' ')
      # in formula's, prefix names that are defined in @vars with `@vars.':
      form.gsub!(varexp) do
        if @vars.respond_to?($1)
          "@vars."+$1
        else
          quit("Line #{lineno}: Undefined variable #{$1}")
        end
      end
      varlist.push(enter(var,form,routine))
      @singulars.push(var) # remember which vars to prefix with _
    else # manual array
      varlist.push(enter(var,form.map { |x| x.to_f }.to_s+'.to_magic',preamble))
    end
  end
end

o.list ||= varlist
(l = o.list-varlist).empty? or quit("unknown variable#{l.size>1 ? 's' : ''} #{l} in --list option")
maxlen = varlist.map {|v| v.size}.max # max length of variable name

# test if o.plot contains nonconstant singulars variables only::
d = (o.plot||[])-@singulars
unless d.empty? 
  if d.size == 1 
    quit("You want a plot of #@last vs. #{d.shift}, but #{d.shift} not a non-constant singular variable")
  else
    quit("You want a plots of #@last vs. #{d.join(' and ')}, but those aren't non-constant singular variables")
  end
end

if VERBOSE
  puts 'stepping, type <ctrl-C> to stop '.err
  o.list.each do |v|
    routine << "  puts '#{v.ljust(maxlen)}:'.sub(/^_/,'') + #{v}.pr(#{o.width})\n"
  end
  routine << %q{
    q = gets
    exit if q.strip == 'q'
  }
end
routine << "\n  @npvs.push(_#@last)\n"
o.plot.each { |v| routine << "@_#{v}_samples.push(_#{v})\n" } if o.plot
routine << "\n  return(_#{varlist[-1]})\nend\n\n"

# make internal vars non-constants with _ prefix
@singulars.each { |v|
  routine = routine.gsub(/\b#{v}\b/m,'_'+v).sub(/(^  puts .)_/m,'\1')
}

postamble = ''
o.plot.each { |v| postamble << "  @_#{v}_samples = []\n" } if o.plot
postamble << POSTAMBLE.result(binding)

script = preamble + "\n@npvs=[]\n" + routine + postamble
tf = Tempfile.new('mcarlo')
puts "Run file: #{tf.path.err}"
tf.puts script
tf.close
exec 'ruby '+tf.path

# __TEMPLATES__
BEGIN {
  require 'erb'

  PREAMBLE = ERB.new(<<-'EOD'.tr("\t",""),nil,'%')
	#!/usr/bin/env ruby
	# encoding: utf-8
	require 'wdstats'
	require 'rubystats'
	require 'tempfile'
	   number = <%= o.number %>
	    every = number/100
	     seed = <%= o.seed %>
	starttime = Time.now
	srand(seed.to_i) if seed
	class String 
	  def beautify; self.gsub(/([a-z])([A-Z])/,'\1 \2').gsub(/([A-Z]+)([A-Z][a-z])/,'\1 \2'); end
	end
	EOD

  POSTAMBLE = ERB.new(<<-'EOD'.tr("\t",""),nil,'%')
	npv,mlast = [],[]
	th = Thread.new do
	  Thread.current['ready'] = 0
	  open(%Q{|feedgnuplot \
	    --lines \
	    --points \
	    --extracmds 'set logscale y2' \
	    --stream 0 \
	    --xmin 0 --xmax 100 \
	    --title "mcarlo2 n=<%= o.number %> seed=<%= o.seed || 'random'  %>" \
	    --y2 1 \
	    --stream \
	    --legend 0 '<%= varlist.last %> mean' \
	    --legend 1 'SD last 10' \
	    --ylabel '<%= varlist.last.beautify %> mean' \
	    --y2label 'SD last 10'},'w') do |plot|
	% if VERBOSE
	    puts "%11s %14s" % ["<%= varlist.last %>",'St. dev.']
	% end
	    number.times do |i|
	      npv.push(mccalc)
	      s = 0
	      if i % every == 0
	        if npv.size > 1 &&npv.uniq.size == 1
	          puts("<%= varlist.last %> has a constant value of #{npv.shift}")
	          exit 1
	        end
	        m = npv.mean
	        mlast.push(m)
	        if mlast.size >=10
	          s = mlast[-10..-1].psd
	          plot.puts "#{m} #{s}"
	          plot.flush
	        end
	% if VERBOSE
	        puts [m.pr(<%= o.width %>),s.pr(<%= o.width %>)].join(' ')
	% end
	      end
	    end
	    Thread.current['ready'] = 1
	  end
	end
	while true do
	  r = th['ready'] || 0
	  break if r == 1
	  sleep 1 
	end

	puts npv.info("\nTest run with seed=<%= o.seed || 'random' %>")
	t = Time.now - starttime
	if t > 600 
	  t/=60
	  unit = 'minutes'
	else
	  unit = 'seconds'
	end
	puts "           Run time (%s): %#12.3g" % [unit,t]
	e,y = nil,-275
	% if o.plot
	  ["<%= (o.plot).join('","') %>"].each do |x|
	    eval "e = @_#{x}_samples"
	    if e[0].class != Float then
	        puts("[1;31mYou can not plot #{x} because it is an array[0m")
	        next
	    end
	    #open(x+'.log','w') do |v| v.puts e.sort { |a,b| a<=>b } end
	    #open(x+'.log','w') do |v| v.puts e.sort { |a,b| a<=>b } end
	    tmp = Tempfile.new('mcarlo')
	    e.zip(@npvs).each { |v| tmp.puts v.join(' ') }
	    body = <<EOF
	      n=50
	      min=#{e.min}
	      max=#{e.max}
	      width=(max-min)/n
	      hist(x,w)=w*floor(x/w)+w/2.0
	      set tics out nomirror
	      set xrange [min:max]
	      set x2range [min:max]
	      set xlabel "#{x.beautify}"
	      set ylabel "Frequency" tc rgb 'blue'
	      set y2label '<%= @last.beautify %>' tc rgb 'red'
	      set y2tics out nomirror
	      <%= o.ylog ? 'set logscale y2' : '' %>
	      plot '#{tmp.path}' u (hist($1*1.0,width)):(1.0) smooth freq with boxes linecolor rgb "blue" title '' axes x1y1, \
	           '#{tmp.path}' with dots linecolor rgb "red" title '' axes x2y2
	EOF
	    open("|gnuplot -geometry +0+#{y+=275} -display :0.0 -persist","w") do |p|
	      p.puts 'set terminal x11 size 640,232',body
	    end
	    open("|gnuplot","w") do |p|
	      p.puts "set terminal png font '<%= o.font %>'","set output '#{x}.png'",body
	    end
	  end
	% end
	  e = @npvs
	  pf = Tempfile.new('mcarlo')
          pf.puts e.sort { |a,b| a<=>b }
	  pfpath = pf.path
	  pf.close
	  body = <<EOF
	    n=50  #number of intervals
	    min=#{e.min}
	    max=#{e.max}
	    width=(max-min)/n
	    hist(x,w)=w*floor(x/w)+w/2.0
	    set tics out nomirror
	    set xrange [min:max]
	    set autoscale y
	    set xlabel "<%= @last.beautify %>" 
	    set ylabel "Frequency" tc rgb 'blue'
	    set y2label 'percent'
	    set ytics nomirror
	    set y2tics
	    set grid y2
	    set y2range [0:100]
	    x=0
	    plot "#{pfpath}" u (hist($1,width)):(1.0) axes x1y1 smooth freq with boxes linecolor rgb "blue" title '', \
	          "" u ($1):(x=x+100.0/#{@npvs.size}) t 'count' axes x1y2 w l
	EOF
	  open("|gnuplot -geometry +0+#{y+=275} -display :0.0 -persist","w") do |p|
	    p.puts 'set terminal x11 size 640,232',body
	  end
	  open("|gnuplot","w") do |p| # -geometry +0+#{y+=275} -display :0.0 -persist","w") do |p|
	    p.puts "set terminal png font '<%= o.font %>'",'set output "<%= @last %>.png"',body
	  end
	  
	  pids = `ps -o pid= -o comm=`.
	  	split("\n").
	  	map {|v| v =~ /(gnuplot|perl)/ ? v.strip.split[0] : nil}.
	  	compact
	  puts pids.join(' ')
	  puts "Type <enter> to stop"
	  gets
	  pids.each do |v|
	    system("kill",v)
	  end
	EOD
}
# $Id$
