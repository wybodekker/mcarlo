#!/usr/bin/env ruby

require 'ostruct'
require 'erb'
require 'wdstats'
require 'tempfile'
require 'scriptingutils'
require_relative '../lib/mcarlo/version'
Version = Mcarlo::VERSION

class Array
  # return the type of the array in mcarlo terms:
  # a simple assignment, a formula, an array of values, an empty array
  def formtype
    j = join
    if j =~ /^[-+.[:digit:]]+$/ # numeric chars only?
      return :simple_assignment if size == 1
      return :array
    elsif j =~ /^dist\(/
      if j =~ /^dist\((['"])(normal|lognormal|uniform|triangular)\1,[-+.\d]+%?,[-+.\d]+%?(,[-+.\d]+%?)?\)/
        return :dist
      else
        quit("Distribution expression (#{j}) malformed")
      end
    elsif j =~ /^([^A-Za-z0-9(])/ 
      quit("A formula (#{join(' ')}) may not start with #{$1}")
    else
      return :formula
    end
  end
end

# make entry in @vars and return the name of the variable defined
def enter(k,v,str)
  @last = k
  line = "@vars.#{k} = #{v}"
  str << line.gsub(/@vars\./,'')+"\n"
  puts line.gsub(/@vars\./,'') if VERBOSE
  eval line
  k
end

def handle_options
  o = OpenStruct.new( 
    :distros   => nil,
    :list      => nil,
    :infile    => nil,
    :seed      => nil,
    :width     => 8,
    :number    => 10_000,
    :verbose   => nil,
    :ylog      => false,
    :font      => 'Courier,10',
  )
  ARGV.options do |opt|
    opt.banner =  "#{MYNAME} - evaluatie van bedrijfsresultaten met MonteCarlo faciliteiten\n"
    opt.banner << "Usage: #{MYNAME} [options] filename"
    opt.separator "Options:"
 
    opt.on('-n','--number=INT',Integer,
        	'set number of runs to INT',
        	'must be a multiple of 100',
        	"default: #{o.number.beautify}") do |v|
      (v > 0) && (v % 100 == 0) or quit("The number of runs must be a multiple of 100")
      o.number = v
    end
 
    opt.on('-s','--seed=INT',Integer,
                'random seed - causes a fixed set of random numbers to be used') do |v| o.seed = v end
 
    opt.on('-w','--width=INT',Integer,"printing width for numbers, default: #{o.width}") do |v| o.width = v end
 
    opt.on('-l','--list=string',String,
      'variables to be displayed, comma-separated',
      'implies --verbose') do |v|
      o.list = v.split(',')
      o.verbose = true
    end
 
    opt.on('-p','--plot=string',String,
      'variables to be plotted, comma-separated') do |v|
      o.plot = v.split(',')
    end
 
    opt.on('-f','--font=string',String,
      "font for png output, default: '#{o.font}'") do |v|
      o.font = v
    end

    opt.on('-y','--ylog','Frequency (left) Y-axis logarithmic for scatter plots') do o.ylog = true end
 
    opt.on('-h','--help',
      'print this help and exit'
    ) do puts opt.help; exit; end
 
    opt.on('-v','--verbose',
      'show values of all (or all --list-specified) variables for each step'
    ) do o.verbose = true end
 
    opt.on('-V','--version',
      'print version and exit'
    ) do print_version end
    opt.parse!
  end or quit("Error parsing options",1)
  o.infile = ARGV.shift
  if ! o.infile then
    if File.exist?('data.txt') then
      o.infile = 'data.txt' 
    else
      quit("I need a filename or your input file must be named data.txt")
    end
  end
  test(?e,o.infile)  or quit("File #{o.infile} does not exist")
  test(?r,o.infile)  or quit("File #{o.infile} is not readable")
  ARGV.empty? or quit("too many arguments: "+ARGV.join(" "))
  o
end


o = init(%w{gnuplot},:handle_options)

@vars = OpenStruct.new
OPS = ['+','-','*','/','?',':','<','>','<=','>=','**']

@last = nil	# last variable - something like NPV
@singulars = []	# names of non-constant singular variables that were defined

lineno = 0
routine = "def mccalc\n"
varlist,varexp = [],Regexp.new(/([A-Z][a-zA-Z]*)/)

# declare the preamble here, but read the template into it only after any
# option statements have been read from the input file.
preamble = nil
open(o.infile) do |infile|
  infile.readlines.each do |l|
    lineno += 1
    l.sub!(/\s*#.*/,'')
    next if l =~ /^\s*$/ # skip lege regels
    
    # replace number-fields ending in % with number/100
    l.gsub!(/([-+.0-9]+)%/) { |x| x.to_f/100 }
    var,*form = l.chomp.split(/\s+/)
    var,*form = l.chomp.split(/\s+/)
    var =~ /^[A-Z]/ or quit("User variables (#{var}) must be capitalized")

    # catch options:
    if var =~ /--(.*)/ then
      preamble && quit("All option statements must be in the beginning of the input file!")
      op = $1
      if op =~/^(plot|list)/ then
        eval "o.#{op} = (form[0]||'').split(',')"
      else 
        eval "o.#{op} = form.join(' ')"
      end
      next
    end
    
    # options must have been read now 
    preamble ||= PREAMBLE.result(binding)
    VERBOSE = o.verbose unless defined? VERBOSE
    form.map! do |x|
      # test validity of operators
      x.scan(/[-+*\/<>?:]+/).each do |op|
        OPS.index(op) or quit("Line #{lineno}: Operator #{op} is not allowed; maybe you need parentheses?")
      end
      x = nil if x.gsub(/\s+/,'').empty?
      x
    end

    case form.formtype
    when :simple_assignment
      varlist.push(enter(var,form[0],preamble))
    when :dist
        varlist.push(enter(var,form.join,preamble))
    when :formula
      form = form.join(' ')
      # in formula's, prefix names that are defined in @vars with `@vars.':
      form.gsub!(varexp) do
        if @vars.respond_to?($1)
          "@vars."+$1
        else
          quit("Line #{lineno}: Undefined variable #{$1}")
        end
      end
      varlist.push(enter(var,form,routine))
      @singulars.push(var) # remember which vars to prefix with _
    else # manual array
      varlist.push(enter(var,form.map { |x| x.to_f }.to_s+'.to_magic',preamble))
    end
  end
end

o.list ||= varlist
(l = o.list-varlist).empty? or quit("unknown variable#{l.size>1 ? 's' : ''} #{l} in --list option")
maxlen = varlist.map {|v| v.size}.max # max length of variable name

if VERBOSE
  puts 'stepping, type <ctrl-C> to stop '.err
  o.list.each do |v|
    routine << "  puts '#{v.ljust(maxlen)}:'.sub(/^_/,'') + #{v}.pr(#{o.width})\n"
  end
  routine << %q{
    q = gets
    exit if q.strip == 'q'
  }
end
routine << "\n  @lastvar_samples.push(_#@last)\n"
o.plot.each { |v| routine << "@_#{v}_samples.push(_#{v})\n" } if o.plot
routine << "\n  return(_#{varlist[-1]})\nend\n\n"

# make internal vars non-constants with _ prefix
@singulars.each { |v|
  routine = routine.gsub(/\b#{v}\b/m,'_'+v).sub(/(^  puts .)_/m,'\1')
}

postamble = ''
o.plot.each { |v| postamble << "  @_#{v}_samples = []\n" } if o.plot
postamble << POSTAMBLE.result(binding)

script = preamble + "\n@lastvar_samples=[]\n" + routine + postamble
tf = Tempfile.new('mcarlo')
puts "Run file: #{tf.path.err}"
tf.puts script
tf.close
exec 'ruby '+tf.path

# __TEMPLATES__
BEGIN {
  require 'erb'

  PREAMBLE = ERB.new(<<-'EOD'.gsub(/^\t/,''),nil,'%')
	#!/usr/bin/env ruby
	# encoding: utf-8
	require 'wdstats'
	require 'rubystats'
	require 'tempfile'
	   number = <%= o.number %>
	     seed = <%= o.seed %>
	starttime = Time.now
	srand(seed.to_i) if seed
	EOD

  POSTAMBLE = ERB.new(<<-'EOD'.gsub(/^\t/,''),nil,'%')
	npv,p1 = [],number/100
	number.times do |i|
	   npv.push(mccalc)
	% unless VERBOSE
	   printf("\r%3d%%  ",i/p1) if (i/p1)*p1 == i
	% end
	end

	puts "\r100%",npv.info("\nTest run with seed=<%= o.seed || 'random' %>")
	t = Time.now - starttime
	t,unit = (t>600 ? [t/60,'minutes'] : [t,'seconds'])
	puts "           Run time (%s): %#12.3g" % [unit,t]
	e,voffset,error = nil,-275,false
	% if o.plot
	["<%= (o.plot).join('","') %>"].each do |xname|
	  eval "e = @_#{xname}_samples"
	  if e[0].class != Float then
	      puts("[1;31mYou can not plot #{xname} because it is an array[0m")
              error = true
	      next
	  end
	end
	exit 1 if error
	% end
	% if o.plot
	plothist(@lastvar_samples.zip(<%=o.plot.map{|v| '@_'+v+'_samples'}.join(',') %>),
		['<%= @last %>','<%= o.plot.join("','") %>'],
		'<%= o.font %>')
	% else
	plothist(@lastvar_samples.map{|v| [v]},
		['<%= @last %>'],
		'<%= o.font %>')
	% end
	pids = `ps -o pid= -o comm=`.
		split("\n").
		map {|v| v =~ /(gnuplot|perl)/ ? v.strip.split[0] : nil}.
		compact
	puts pids.join(' ')
	puts "Type <enter> to stop"
	gets
	pids.each do |v|
	  system("kill",v)
	end
	EOD
}
# $Id$
