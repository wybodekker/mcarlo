#!/usr/bin/env ruby
require 'ostruct'
require 'erb'
require 'wdstats'
require 'tempfile'
require 'scriptingutils'
require_relative '../lib/mcarlo/version'
Version = Mcarlo::VERSION

class Array
  # return the type of the array in mcarlo terms:
  # a simple assignment, a formula, an array of values, an empty array
  def formtype
    j = join
    if j =~ /^'(.*)'$/
      return :simple_assignment
    elsif j =~ /^[-+.[:digit:]]+$/ # numeric chars only?
      return :simple_assignment if size == 1
      return :array
    elsif j =~ /^dist\(/
      if j =~ /^dist\((['"])(normal|lognormal|uniform|triangular)\1,[-+.\d]+%?,[-+.\d]+%?(,[-+.\d]+%?)?\)/
        return :dist
      else
        quit("Distribution expression (#{j}) malformed")
      end
    elsif j =~ /^([^A-Za-z0-9(])/ 
      quit("A formula (#{join(' ')}) may not start with #{$1}")
    else
      return :formula
    end
  end
end

CONV = {
  /\.count/  => ".count(@vars.Nyears)",
  /\.grow\(/ => ".grow(@vars.Nyears,",
  /\.npv/  => ".npv(@vars.R,@vars.SGR,@vars.InitR,@vars.RevSpd,@vars.LtEq,@vars.Volat)",
}

# make entry in @vars and return the name of the variable defined
def enter(k,v,str)
  @last = k
  line = "@vars.#{k} = #{v}"
  CONV.each { |k,v| line.gsub!(k,v) }
  str << line.gsub(/@vars\./,'')+"\n"
  eval line
  k
end

def handle_options
  ARGV.options do |opt|
    opt.banner =  "#{MYNAME} - evaluatie van bedrijfsresultaten met MonteCarlo faciliteiten\n"
    opt.banner << "Usage: #{MYNAME} [options] [filename]"
    opt.separator "Options:"
 
    opt.on('-h','--help',
      'print this help and exit'
    ) do puts opt.help; exit; end
 
    opt.on('-V','--version',
      'print version and exit'
    ) do print_version end
    opt.parse!
  end or quit("Error parsing options",1)
  infile = ARGV.shift # may be nil`
  ARGV.empty? or quit("too many arguments: "+ARGV.join(" "))
  inlines = []
  if infile # input file specified
    test(?e,infile)  or quit("File #{infile} does not exist")
    test(?r,infile)  or quit("File #{infile} is not readable")
    open(infile) { |i| inlines = i.readlines }
    path = File.dirname(File.absolute_path(infile))
  else	# read input from stdin
    inlines = STDIN.readlines
    path = '.'
  end
  return [path,inlines]
end
OPS = ['+','-','*','/','?',':','<','>','<=','>=','**']
@vars = OpenStruct.new(
  :Plot		=> '',
  :List		=> '',
  :Font		=> 'Georgia',
  :Nyears	=> 8,
  :Niter	=> 10000,
  :Seed		=> 0,
  :Width	=> 8,
  :Ylog		=> 0,
  :R		=> 0.05,
  :SGR		=> 0,
  :InitR	=> 0,
  :RevSpd	=> 0,
  :LtEq		=> 0,
  :Volat	=> 0,
)

path,inlines = init(%w{gnuplot},:handle_options)

@last = nil	# last variable - something like NPV
@singulars = []	# names of non-constant singular variables that were defined

lineno = 0
routine = "def mccalc\n"
varlist,varexp = [],Regexp.new(/([A-Z][a-zA-Z]*)/)

# declare the preamble here, but read the template into it only after any
# option statements have been read from the input file.
preamble = nil
inlines.each do |l|
  lineno += 1
  l.sub!(/\s*#.*/,'')
  next if l =~ /^\s*$/ # skip lege regels
  
  # replace number-fields ending in % with number/100
  l.gsub!(/([-+.0-9]+)%/) { |x| x.to_f/100 }
  var,*form = l.chomp.split(/\s+/)
  var,*form = l.chomp.split(/\s+/)
  var =~ /^[A-Z]/ or quit("User variables (#{var}) must be capitalized")

  preamble ||= PREAMBLE.result(binding)
  form.map! do |x|
    # test validity of operators
    x.scan(/[-+*\/<>?:]+/).each do |op|
      OPS.index(op) or quit("Line #{lineno}: Operator #{op} is not allowed; maybe you need parentheses?")
    end
    x = nil if x.gsub(/\s+/,'').empty?
    x
  end

  case form.formtype
  when :simple_assignment
    varlist.push(enter(var,form.join(' '),preamble))
  when :dist
      varlist.push(enter(var,form.join,preamble))
  when :formula
    #--@verbose = !@vars.List.empty?
    form = form.join(' ')
    # in formula's, prefix names that are defined in @vars with `@vars.':
    form.gsub!(varexp) do
      if @vars.respond_to?($1)
        "@vars."+$1
      else
        quit("Line #{lineno}: Undefined variable #{$1}")
      end
    end
    varlist.push(enter(var,form,routine))
    @singulars.push(var) # remember which vars to prefix with _
  else # manual array
    varlist.push(enter(var,form.map { |x| x.to_f }.to_s+'.to_magic',preamble))
  end
end

lastclass = @vars.send(@singulars[-1]).class
lastclass == Float ||
  quit("The last variable (#{@singulars[-1]}) should be a Float, but it is a #{lastclass}")
# make internal vars non-constants with _ prefix
@singulars.each { |v|
  routine = routine.gsub(/\b#{v}\b/m,'_'+v).sub(/(^  puts .)_/m,'\1')
}

tf = Tempfile.new('mcarlo')
puts "Run file: #{tf.path.err}"
tf.puts preamble
tf.puts routine 
unless @vars.List.empty?
  puts 'stepping, type <ctrl-C> to stop '.err
  maxlen = @vars.List.split.map {|v| v.size}.max # max length of variable name
  @vars.List.split.each do |v|
    quit("#{v} cannot be listed, because it's an undefined variable") unless @vars.send(v)
    quit("#{v} cannot be listed, because it's a string") if @vars.send(v).class == String
    tf.puts "  puts '#{v.ljust(maxlen)}:'.sub(/^_/,'') + #{v}.pr(Width)"
  end
  tf.puts 'q = gets'
  tf.puts 'exit if q.strip == "q"'
end
tf.puts "\n  @lastvar_samples.push(_#@last)"
@vars.Plot.split.each { |v| tf.puts "@_#{v}_samples.push(_#{v})" }
tf.puts "\n  return(_#{varlist[-1]})\nend\n"

@vars.Plot.split.each { |v| tf.puts "  @_#{v}_samples = []" }
tf.puts POSTAMBLE.result(binding)
tf.close
exec 'ruby '+tf.path

# __TEMPLATES__
BEGIN {
  require 'erb'

  PREAMBLE = ERB.new(<<-'EOD'.gsub(/^\t/,''),nil,'%')
	#!/usr/bin/env ruby
	# encoding: utf-8
	require 'wdstats'
	require 'rubystats'
	require 'tempfile'
	starttime = Time.now
	Version = <%= Version %>
	@lastvar_samples=[]
	EOD

  POSTAMBLE = ERB.new(<<-'EOD'.gsub(/^\t/,''),nil,'%')
	srand(Seed) if Seed != 0
	npv,p1 = [],Niter/100
	Niter.times do |i|
	   npv.push(mccalc)
	% if @vars.List.empty?
	   printf("\r%3d%%  ",i/p1) if (i/p1)*p1 == i
	% end
	end

	puts "\r100%",npv.info(Version,"\n#{Title} with Seed=#{Seed==0 ? 'random' : Seed}")
	t = Time.now - starttime
	t,unit = (t>600 ? [t/60,'minutes'] : [t,'seconds'])
	puts "           Run time (%s): %#12.3g" % [unit,t]
	if npv.min == npv.max then 
	   puts "constant output  (#{npv.mean}) - no plot"
	   exit 2
	end
	e,voffset,error = nil,-275,false
	Plot.split.each do |xname|
	  eval "e = @_#{xname}_samples"
	  if e[0].class != Float then
	      puts("You can not plot #{xname} because it is an array")
              error = true
	      next
	  end
	end
	exit 1 if error
	% if ! @vars.Plot.empty?
	plothist('<%= path %>',@lastvar_samples.zip(<%=@vars.Plot.split.map{|v| '@_'+v+'_samples'}.join(',') %>),
		['<%= @last %>'] + Plot.split,
		Font,
		Ylog > 0)
	% else
	plothist('<%= path %>',@lastvar_samples.map{|v| [v]},
		['<%= @last %>'],
		Font,
		Ylog > 0)
	% end
	EOD
}
